/**
 * Workflow Service â€” Merge Implementation PR
 *
 * Merges an implementation PR. Handles single-phase,
 * multi-phase middle, and multi-phase final scenarios.
 * Extracted from Telegram handler so both Telegram and UI
 * share the same code path.
 */

import { STATUSES, COMMIT_MESSAGE_MARKER } from '@/server/template/project-management/config';
import { parseCommitMessageComment } from '@/agents/lib/commitMessage';
import {
    parsePhaseString,
    updateImplementationPhaseArtifact,
    getTaskBranch,
    generateTaskBranchName,
} from '@/agents/lib';
import { getArtifactsFromIssue, getCommitMessage, savePhaseStatusToDB } from '@/agents/lib/workflow-db';
import {
    logWebhookAction,
    logWebhookPhaseStart,
    logWebhookPhaseEnd,
    logExists,
} from '@/agents/lib/logging';
import { setFinalPrNumber, setLastMergedPr } from '@/server/database/collections/template/workflow-items';
import { getInitializedAdapter, findItemByIssueNumber, logHistory } from './utils';
import { markDone } from './advance';
import { advanceImplementationPhase } from './phase';
import { advanceStatus } from './advance';
import type { ServiceResult } from './types';

export interface MergePRResult extends ServiceResult {
    mergeCommitSha?: string;
    advancedTo?: string;
    previousStatus?: string;
    phaseInfo?: { current: number; total: number; next?: number };
    finalPrCreated?: { prNumber: number; prUrl: string };
    statusMessage?: string;
}

/**
 * Create the final PR from feature branch to main for multi-phase workflow.
 */
async function createFinalPRToMain(
    adapter: Awaited<ReturnType<typeof getInitializedAdapter>>,
    issueNumber: number,
    totalPhases: number,
    issueTitle: string
): Promise<{ prNumber: number; prUrl: string } | null> {
    const taskBranch = generateTaskBranchName(issueNumber);
    const defaultBranch = await adapter.getDefaultBranch();

    const prTitle = `feat: ${issueTitle}`;
    const prBody = `## Summary

This PR contains all ${totalPhases} phases of the implementation for issue #${issueNumber}.

### Phases Completed
${Array.from({ length: totalPhases }, (_, i) => `- Phase ${i + 1}/${totalPhases}`).join('\n')}

Closes #${issueNumber}

---

**Feature Branch Workflow:**
This is the final PR from the feature branch (\`${taskBranch}\`) to \`${defaultBranch}\`.
All individual phase PRs have been reviewed and merged to the feature branch.

*Generated by Agent Workflow*`;

    try {
        const pr = await adapter.createPullRequest(
            taskBranch,
            defaultBranch,
            prTitle,
            prBody,
            []
        );

        if (logExists(issueNumber)) {
            logWebhookAction(issueNumber, 'final_pr_created', `Final PR #${pr.number} created: ${taskBranch} â†’ ${defaultBranch}`, {
                prNumber: pr.number,
                taskBranch,
                defaultBranch,
                totalPhases,
            });
        }

        return { prNumber: pr.number, prUrl: pr.url };
    } catch (error) {
        console.error(`  [LOG:ERROR] [FEATURE_BRANCH] Failed to create final PR: ${error instanceof Error ? error.message : String(error)}`);

        if (logExists(issueNumber)) {
            const { logExternalError } = await import('@/agents/lib/logging');
            logExternalError(issueNumber, 'webhook', error instanceof Error ? error : new Error(String(error)));
        }

        return null;
    }
}

/**
 * Merge an implementation PR.
 *
 * 1. Gets commit message from DB (fallback to PR comment)
 * 2. Merges PR (handles already-merged gracefully)
 * 3. Updates phase artifact status
 * 4. Multi-phase middle: advances to next phase
 * 5. Multi-phase final with task branch: creates final PR, saves finalPrNumber, advances to Final Review
 * 6. Multi-phase final no task branch / single-phase: marks done
 * 7. Deletes PR head branch
 */
export async function mergeImplementationPR(
    issueNumber: number,
    knownPrNumber?: number
): Promise<MergePRResult> {
    const adapter = await getInitializedAdapter();

    // Find item to get PR number
    const item = await findItemByIssueNumber(issueNumber);
    if (!item) {
        return { success: false, error: `Issue #${issueNumber} not found in project` };
    }

    // Get implementation phase to find the current PR
    const phase = await adapter.getImplementationPhase(item.itemId);
    const parsedPhase = parsePhaseString(phase);

    const artifact = await getArtifactsFromIssue(adapter, issueNumber);

    // Find the current PR number: use caller-provided value first, fall back to artifact discovery
    let prNumber: number | undefined = knownPrNumber;
    if (!prNumber) {
        if (parsedPhase) {
            const currentPhaseArtifact = artifact?.implementation?.phases?.find(
                p => p.phase === parsedPhase.current
            );
            prNumber = currentPhaseArtifact?.prNumber;
        } else {
            // Single-phase: get the latest PR from phases
            prNumber = artifact?.implementation?.phases?.[0]?.prNumber;
        }
    }

    if (!prNumber) {
        return { success: false, error: `No PR found for issue #${issueNumber}` };
    }

    // Get commit message from DB, fallback to PR comment
    let commitMsg = await getCommitMessage(issueNumber, prNumber);
    if (!commitMsg) {
        const commitComment = await adapter.findPRCommentByMarker(prNumber, COMMIT_MESSAGE_MARKER);
        if (!commitComment) {
            return { success: false, error: 'Commit message not found on PR. Please run PR Review again.' };
        }
        commitMsg = parseCommitMessageComment(commitComment.body);
        if (!commitMsg) {
            return { success: false, error: 'Could not parse commit message. Please run PR Review again.' };
        }
    }

    if (logExists(issueNumber)) {
        logWebhookPhaseStart(issueNumber, 'PR Merge', 'webhook');
    }

    // Merge the PR
    let mergeCommitSha: string | null = null;
    try {
        mergeCommitSha = await adapter.mergePullRequest(prNumber, commitMsg.title, commitMsg.body);
        if (logExists(issueNumber)) {
            logWebhookAction(issueNumber, 'pr_merged', `PR #${prNumber} squash-merged`, {
                prNumber,
                commitTitle: commitMsg.title,
                mergeCommitSha,
            });
        }
    } catch (mergeError) {
        const errorMsg = mergeError instanceof Error ? mergeError.message : String(mergeError);
        if (errorMsg.includes('already been merged') ||
            errorMsg.includes('Pull Request is not mergeable') ||
            errorMsg.includes('not open')) {
            mergeCommitSha = await adapter.getMergeCommitSha(prNumber);
            if (logExists(issueNumber)) {
                logWebhookAction(issueNumber, 'pr_already_merged', `PR #${prNumber} was already merged`, {
                    prNumber,
                    mergeCommitSha,
                });
            }
        } else {
            return { success: false, error: `Failed to merge PR #${prNumber}: ${errorMsg}` };
        }
    }

    // Persist last merged PR info for UI revert capability
    await setLastMergedPr(issueNumber, prNumber, parsedPhase ? `${parsedPhase.current}/${parsedPhase.total}` : undefined);

    const currentPhaseArtifact = artifact?.implementation?.phases?.find(
        p => parsedPhase && p.phase === parsedPhase.current
    );
    const phaseName = currentPhaseArtifact?.name || (parsedPhase ? `Phase ${parsedPhase.current}` : '');

    let statusMessage = '';
    let isMultiPhaseMiddle = false;
    let phaseInfo: MergePRResult['phaseInfo'] | undefined;
    let finalPrCreated: MergePRResult['finalPrCreated'] | undefined;

    if (parsedPhase) {
        const taskBranch = getTaskBranch(artifact);

        try {
            await savePhaseStatusToDB(issueNumber, parsedPhase.current, 'merged', prNumber);
            await updateImplementationPhaseArtifact(
                adapter,
                issueNumber,
                parsedPhase.current,
                parsedPhase.total,
                phaseName,
                'merged',
                prNumber
            );
        } catch {
            console.error('workflow-service: failed to update artifact comment');
        }

        if (parsedPhase.current < parsedPhase.total) {
            // Multi-phase middle
            isMultiPhaseMiddle = true;
            const nextPhase = parsedPhase.current + 1;
            phaseInfo = { current: parsedPhase.current, total: parsedPhase.total, next: nextPhase };

            const phaseCompleteComment = `âœ… **Phase ${parsedPhase.current}/${parsedPhase.total}** complete - Merged PR #${prNumber}\n\nðŸ”„ Starting Phase ${nextPhase}/${parsedPhase.total}...`;
            await adapter.addIssueComment(issueNumber, phaseCompleteComment);

            await advanceImplementationPhase(
                issueNumber,
                `${nextPhase}/${parsedPhase.total}`,
                STATUSES.implementation,
                {
                    logAction: 'phase_complete',
                    logDescription: `Phase ${parsedPhase.current}/${parsedPhase.total} complete`,
                    logMetadata: {
                        currentPhase: parsedPhase.current,
                        totalPhases: parsedPhase.total,
                        nextPhase,
                        prNumber,
                    },
                }
            );

            statusMessage = `Phase ${parsedPhase.current}/${parsedPhase.total} complete, starting Phase ${nextPhase}/${parsedPhase.total}`;
        } else {
            // Final phase
            phaseInfo = { current: parsedPhase.current, total: parsedPhase.total };

            if (taskBranch) {
                const issueDetails = await adapter.getIssueDetails(issueNumber);
                const issueTitle = issueDetails?.title || `Issue #${issueNumber}`;

                const finalPR = await createFinalPRToMain(adapter, issueNumber, parsedPhase.total, issueTitle);

                if (finalPR) {
                    finalPrCreated = finalPR;

                    // Save final PR number to DB
                    await setFinalPrNumber(issueNumber, finalPR.prNumber);

                    const finalPRComment = `âœ… **Phase ${parsedPhase.current}/${parsedPhase.total}** complete - Merged PR #${prNumber}\n\nðŸš€ **All phases merged to feature branch!**\nðŸ“‹ Final PR created: #${finalPR.prNumber}\n\nAwaiting admin verification via Vercel preview before merge to main.`;
                    await adapter.addIssueComment(issueNumber, finalPRComment);

                    await advanceStatus(issueNumber, STATUSES.finalReview, {
                        logAction: 'final_review',
                        logDescription: `All phases complete, final PR #${finalPR.prNumber} created`,
                        logMetadata: {
                            totalPhases: parsedPhase.total,
                            finalPrNumber: finalPR.prNumber,
                            taskBranch,
                        },
                    });

                    isMultiPhaseMiddle = true;
                    statusMessage = `All ${parsedPhase.total} phases complete, final PR #${finalPR.prNumber} created`;
                } else {
                    const fallbackComment = `âœ… **Phase ${parsedPhase.current}/${parsedPhase.total}** complete - Merged PR #${prNumber}\n\nâš ï¸ Failed to create final PR. Please manually merge the feature branch (\`${taskBranch}\`) to main.`;
                    await adapter.addIssueComment(issueNumber, fallbackComment);
                    await adapter.clearImplementationPhase(item.itemId);
                    statusMessage = `All ${parsedPhase.total} phases complete, final PR creation failed`;
                }
            } else {
                const allPhasesCompleteComment = `âœ… **Phase ${parsedPhase.current}/${parsedPhase.total}** complete - Merged PR #${prNumber}\n\nðŸŽ‰ **All ${parsedPhase.total} phases complete!** Issue is now Done.`;
                await adapter.addIssueComment(issueNumber, allPhasesCompleteComment);
                await adapter.clearImplementationPhase(item.itemId);

                if (logExists(issueNumber)) {
                    logWebhookAction(issueNumber, 'all_phases_complete', `All ${parsedPhase.total} phases complete`, {
                        totalPhases: parsedPhase.total,
                        prNumber,
                    });
                }

                statusMessage = `All ${parsedPhase.total} phases complete`;
            }
        }
    } else {
        // Single phase
        try {
            await savePhaseStatusToDB(issueNumber, 1, 'merged', prNumber);
            await updateImplementationPhaseArtifact(adapter, issueNumber, 1, 1, '', 'merged', prNumber);
        } catch {
            console.error('workflow-service: failed to update artifact comment (single-phase)');
        }

        const completionComment = `âœ… Merged PR #${prNumber} - Issue complete!`;
        await adapter.addIssueComment(issueNumber, completionComment);
        statusMessage = 'Merged â€” marked as Done';
    }

    // Mark as Done if not a multi-phase middle
    if (!isMultiPhaseMiddle) {
        try {
            await markDone(issueNumber, {
                logAction: 'status_done',
                logDescription: 'Issue marked as Done',
                logMetadata: { prNumber },
            });
        } catch (error) {
            console.error(`[MERGE:CRITICAL] Failed to mark done for issue #${issueNumber}:`, error);
        }
    }

    // Delete PR head branch
    try {
        const prDetails = await adapter.getPRDetails(prNumber);
        if (prDetails?.headBranch) {
            await adapter.deleteBranch(prDetails.headBranch);
            if (logExists(issueNumber)) {
                logWebhookAction(issueNumber, 'branch_deleted', `Branch ${prDetails.headBranch} deleted`, {
                    branch: prDetails.headBranch,
                });
            }
        }
    } catch {
        // Branch may already be deleted
    }

    if (logExists(issueNumber)) {
        logWebhookPhaseEnd(issueNumber, 'PR Merge', 'success', 'webhook');
    }

    void logHistory(issueNumber, 'pr_merged', `PR #${prNumber} merged`, 'admin');

    return {
        success: true,
        mergeCommitSha: mergeCommitSha || undefined,
        statusMessage,
        phaseInfo,
        finalPrCreated,
    };
}
