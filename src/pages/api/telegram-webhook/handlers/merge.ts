/* eslint-disable restrict-api-routes/no-direct-api-routes */
/**
 * Handlers for PR merge operations
 */

import { getProjectManagementAdapter } from '@/server/project-management';
import { STATUSES, REVIEW_STATUSES, COMMIT_MESSAGE_MARKER, getIssueUrl, getPrUrl } from '@/server/project-management/config';
import { featureRequests, reports } from '@/server/database';
import { parseCommitMessageComment } from '@/agents/lib/commitMessage';
import {
    parsePhaseString,
    updateImplementationPhaseArtifact,
    getTaskBranch,
    generateTaskBranchName,
    clearTaskBranch,
} from '@/agents/lib';
import { getArtifactsFromIssue, getCommitMessage, savePhaseStatusToDB, clearTaskBranchFromDB } from '@/agents/lib/workflow-db';
import { sendNotificationToOwner } from '@/server/telegram';
import { appConfig } from '@/app.config';
import {
    logWebhookAction,
    logWebhookPhaseStart,
    logWebhookPhaseEnd,
    logExternalError,
    logExists,
    syncLogToRepoAndCleanup,
} from '@/agents/lib/logging';
import { editMessageText } from '../telegram-api';
import { escapeHtml, findItemByIssueNumber } from '../utils';
import type { TelegramCallbackQuery, HandlerResult } from '../types';

/**
 * Create the final PR from feature branch to main for multi-phase workflow
 */
async function createFinalPRToMain(
    adapter: Awaited<ReturnType<typeof getProjectManagementAdapter>>,
    issueNumber: number,
    totalPhases: number,
    issueTitle: string
): Promise<{ prNumber: number; prUrl: string } | null> {
    console.log(`  [LOG:FEATURE_BRANCH] Creating final PR for issue #${issueNumber}`);

    const taskBranch = generateTaskBranchName(issueNumber);
    const defaultBranch = await adapter.getDefaultBranch();

    const prTitle = `feat: ${issueTitle}`;
    const prBody = `## Summary

This PR contains all ${totalPhases} phases of the implementation for issue #${issueNumber}.

### Phases Completed
${Array.from({ length: totalPhases }, (_, i) => `- Phase ${i + 1}/${totalPhases}`).join('\n')}

Closes #${issueNumber}

---

**Feature Branch Workflow:**
This is the final PR from the feature branch (\`${taskBranch}\`) to \`${defaultBranch}\`.
All individual phase PRs have been reviewed and merged to the feature branch.

*Generated by Agent Workflow*`;

    try {
        const pr = await adapter.createPullRequest(
            taskBranch,
            defaultBranch,
            prTitle,
            prBody,
            []
        );

        console.log(`  [LOG:FEATURE_BRANCH] Final PR created: #${pr.number}`);

        if (logExists(issueNumber)) {
            logWebhookAction(issueNumber, 'final_pr_created', `Final PR #${pr.number} created: ${taskBranch} ‚Üí ${defaultBranch}`, {
                prNumber: pr.number,
                taskBranch,
                defaultBranch,
                totalPhases,
            });
        }

        return { prNumber: pr.number, prUrl: pr.url };
    } catch (error) {
        console.error(`  [LOG:ERROR] [FEATURE_BRANCH] Failed to create final PR: ${error instanceof Error ? error.message : String(error)}`);

        if (logExists(issueNumber)) {
            logExternalError(issueNumber, 'webhook', error instanceof Error ? error : new Error(String(error)));
        }

        return null;
    }
}

/**
 * Handle merge final PR callback from Telegram (feature branch workflow)
 * Callback format: "merge_final:issueNumber:prNumber"
 */
export async function handleMergeFinalPRCallback(
    botToken: string,
    callbackQuery: TelegramCallbackQuery,
    issueNumber: number,
    prNumber: number
): Promise<HandlerResult> {
    try {
        console.log(`  [LOG:FINAL_REVIEW] Admin merging final PR #${prNumber} for issue #${issueNumber}`);

        const adapter = getProjectManagementAdapter();
        await adapter.init();

        if (logExists(issueNumber)) {
            logWebhookPhaseStart(issueNumber, 'Final Review Merge', 'telegram');
        }

        const prInfo = await adapter.getPRInfo(prNumber);
        if (!prInfo) {
            console.warn(`[LOG:MERGE] Could not fetch PR info for PR #${prNumber}, issue #${issueNumber}`);
            return { success: false, error: 'Could not fetch PR info' };
        }

        const commitTitle = prInfo.title;
        const commitBody = `Closes #${issueNumber}\n\nFeature branch workflow - final merge to main.`;

        let mergeCommitSha: string | null = null;
        try {
            mergeCommitSha = await adapter.mergePullRequest(prNumber, commitTitle, commitBody);
            console.log(`  [LOG:FINAL_REVIEW] Final PR #${prNumber} merged, commit: ${mergeCommitSha}`);

            if (logExists(issueNumber)) {
                logWebhookAction(issueNumber, 'final_pr_merged', `Final PR #${prNumber} merged to main`, {
                    prNumber,
                    commitTitle,
                    mergeCommitSha,
                });
            }
        } catch (mergeError) {
            const errorMsg = mergeError instanceof Error ? mergeError.message : String(mergeError);
            if (errorMsg.includes('already been merged') || errorMsg.includes('not open')) {
                console.log(`  [LOG:FINAL_REVIEW] Final PR #${prNumber} already merged, continuing`);
                mergeCommitSha = await adapter.getMergeCommitSha(prNumber);
            } else {
                throw mergeError;
            }
        }

        const item = await findItemByIssueNumber(adapter, issueNumber);
        if (!item) {
            console.warn(`  [LOG:WARNING] Project item not found for issue #${issueNumber}`);
        }

        const artifact = await getArtifactsFromIssue(adapter, issueNumber);
        const taskBranch = getTaskBranch(artifact);

        if (item) {
            await adapter.updateItemStatus(item.itemId, STATUSES.done);
            console.log(`  [LOG:FINAL_REVIEW] Status transition: Final Review ‚Üí Done`);

            if (adapter.hasReviewStatusField() && item.reviewStatus) {
                await adapter.clearItemReviewStatus(item.itemId);
            }

            await adapter.clearImplementationPhase(item.itemId);

            if (logExists(issueNumber)) {
                logWebhookAction(issueNumber, 'status_done', 'Final PR merged, issue marked as Done', {
                    status: STATUSES.done,
                    prNumber,
                });
            }

            // Sync S3 log to repo and cleanup (non-blocking)
            syncLogToRepoAndCleanup(issueNumber).catch((err) => {
                console.error(`  [LOG:S3_SYNC] Failed to sync log for issue #${issueNumber}:`, err);
            });
        }

        const featureRequest = await featureRequests.findByGitHubIssueNumber(issueNumber);
        if (featureRequest) {
            await featureRequests.updateFeatureRequestStatus(featureRequest._id, 'done');
            console.log('Telegram webhook: feature request marked as done in database');
        } else {
            const bugReport = await reports.findByGitHubIssueNumber(issueNumber);
            if (bugReport) {
                await reports.updateReport(bugReport._id.toString(), { status: 'resolved' });
                console.log('Telegram webhook: bug report marked as resolved in database');
            }
        }

        console.log(`  [LOG:FEATURE_BRANCH] Cleaning up branches for task-${issueNumber}`);

        if (taskBranch) {
            try {
                await adapter.deleteBranch(taskBranch);
                console.log(`  [LOG:FEATURE_BRANCH] Deleted branch: ${taskBranch}`);
                if (logExists(issueNumber)) {
                    logWebhookAction(issueNumber, 'branch_deleted', `Deleted feature branch: ${taskBranch}`, {
                        branch: taskBranch,
                    });
                }
            } catch {
                console.log(`  [LOG:FEATURE_BRANCH] Feature branch ${taskBranch} already deleted`);
            }
        }

        const totalPhases = artifact?.implementation?.phases?.length || 0;
        for (let i = 1; i <= totalPhases; i++) {
            const phaseBranch = `feature/task-${issueNumber}-phase-${i}`;
            try {
                await adapter.deleteBranch(phaseBranch);
                console.log(`  [LOG:FEATURE_BRANCH] Deleted branch: ${phaseBranch}`);
            } catch {
                // Branch doesn't exist, continue to next
            }
        }

        try {
            await clearTaskBranchFromDB(issueNumber);
            await clearTaskBranch(adapter, issueNumber);
            console.log(`  [LOG:FEATURE_BRANCH] Cleared task branch from artifact`);
        } catch (artifactError) {
            console.warn('Failed to clear task branch from artifact:', artifactError);
        }

        const completionComment = `üéâ **Feature Complete!**\n\nFinal PR #${prNumber} has been merged to main.\nAll phases have been successfully integrated.`;
        await adapter.addIssueComment(issueNumber, completionComment);

        if (logExists(issueNumber)) {
            logWebhookPhaseEnd(issueNumber, 'Final Review Merge', 'success', 'telegram');
        }

        if (callbackQuery.message) {
            const originalText = callbackQuery.message.text || '';
            const statusUpdate = [
                '',
                '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ',
                '‚úÖ <b>Final PR Merged Successfully!</b>',
                `PR #${prNumber} merged to main.`,
                'üéâ Feature is now complete!',
                'üìä Status: Done',
            ].join('\n');

            await editMessageText(
                botToken,
                callbackQuery.message.chat.id,
                callbackQuery.message.message_id,
                escapeHtml(originalText) + statusUpdate,
                'HTML'
            );
        }

        console.log(`  [LOG:FINAL_REVIEW] Completed final merge for issue #${issueNumber}`);
        return { success: true };
    } catch (error) {
        console.error('Error handling final PR merge:', error);

        if (logExists(issueNumber)) {
            logExternalError(issueNumber, 'telegram', error instanceof Error ? error : new Error(String(error)));
        }

        return {
            success: false,
            error: error instanceof Error ? error.message : String(error)
        };
    }
}

/**
 * Handle merge callback from Telegram
 * Callback format: "merge:issueNumber:prNumber"
 */
export async function handleMergeCallback(
    botToken: string,
    callbackQuery: TelegramCallbackQuery,
    issueNumber: number,
    prNumber: number
): Promise<HandlerResult> {
    try {
        const adapter = getProjectManagementAdapter();
        await adapter.init();

        // Try DB first for commit message
        let commitMsg = await getCommitMessage(issueNumber, prNumber);

        // Fallback to PR comment parsing
        if (!commitMsg) {
            const commitComment = await adapter.findPRCommentByMarker(prNumber, COMMIT_MESSAGE_MARKER);
            if (!commitComment) {
                console.warn(`[LOG:MERGE] Commit message not found on PR #${prNumber} for issue #${issueNumber}`);
                return { success: false, error: 'Commit message not found on PR. Please run PR Review again.' };
            }

            commitMsg = parseCommitMessageComment(commitComment.body);
            if (!commitMsg) {
                console.warn(`[LOG:MERGE] Could not parse commit message on PR #${prNumber} for issue #${issueNumber}`);
                return { success: false, error: 'Could not parse commit message. Please run PR Review again.' };
            }
        }

        if (logExists(issueNumber)) {
            logWebhookPhaseStart(issueNumber, 'PR Merge', 'telegram');
        }

        let alreadyMerged = false;
        let mergeCommitSha: string | null = null;
        try {
            mergeCommitSha = await adapter.mergePullRequest(prNumber, commitMsg.title, commitMsg.body);
            console.log(`Telegram webhook: merged PR #${prNumber}, commit: ${mergeCommitSha}`);
            if (logExists(issueNumber)) {
                logWebhookAction(issueNumber, 'pr_merged', `PR #${prNumber} squash-merged`, {
                    prNumber,
                    commitTitle: commitMsg.title,
                    mergeCommitSha,
                });
            }
        } catch (mergeError) {
            const errorMsg = mergeError instanceof Error ? mergeError.message : String(mergeError);
            if (errorMsg.includes('already been merged') ||
                errorMsg.includes('Pull Request is not mergeable') ||
                errorMsg.includes('not open')) {
                console.log(`Telegram webhook: PR #${prNumber} already merged, continuing with status updates`);
                alreadyMerged = true;
                mergeCommitSha = await adapter.getMergeCommitSha(prNumber);
                if (logExists(issueNumber)) {
                    logWebhookAction(issueNumber, 'pr_already_merged', `PR #${prNumber} was already merged`, {
                        prNumber,
                        mergeCommitSha,
                    });
                }
            } else {
                if (logExists(issueNumber)) {
                    logExternalError(issueNumber, 'telegram', mergeError instanceof Error ? mergeError : new Error(errorMsg));
                }
                throw mergeError;
            }
        }

        const item = await findItemByIssueNumber(adapter, issueNumber);
        if (!item) {
            console.warn(`Telegram webhook: project item not found for issue #${issueNumber}`);
            if (alreadyMerged) {
                return { success: true };
            }
        } else {
            console.log(`Telegram webhook: found project item for issue #${issueNumber} (itemId: ${item.itemId})`);
        }

        const phase = item ? await adapter.getImplementationPhase(item.itemId) : null;
        const parsedPhase = parsePhaseString(phase);

        const artifact = await getArtifactsFromIssue(adapter, issueNumber);
        const currentPhaseArtifact = artifact?.implementation?.phases?.find(
            p => parsedPhase && p.phase === parsedPhase.current
        );
        const phaseName = currentPhaseArtifact?.name || (parsedPhase ? `Phase ${parsedPhase.current}` : '');

        let statusMessage = '';
        let isMultiPhaseMiddle = false;

        if (parsedPhase && item) {
            const taskBranch = getTaskBranch(artifact);

            try {
                await savePhaseStatusToDB(issueNumber, parsedPhase.current, 'merged', prNumber);
                await updateImplementationPhaseArtifact(
                    adapter,
                    issueNumber,
                    parsedPhase.current,
                    parsedPhase.total,
                    phaseName,
                    'merged',
                    prNumber
                );
            } catch {
                console.error('Telegram webhook: failed to update artifact comment');
            }

            if (parsedPhase.current < parsedPhase.total) {
                isMultiPhaseMiddle = true;
                const nextPhase = parsedPhase.current + 1;

                const phaseCompleteComment = `‚úÖ **Phase ${parsedPhase.current}/${parsedPhase.total}** complete - Merged PR #${prNumber}\n\nüîÑ Starting Phase ${nextPhase}/${parsedPhase.total}...`;
                await adapter.addIssueComment(issueNumber, phaseCompleteComment);

                await adapter.setImplementationPhase(item.itemId, `${nextPhase}/${parsedPhase.total}`);
                await adapter.updateItemStatus(item.itemId, STATUSES.implementation);

                if (adapter.hasReviewStatusField() && item.reviewStatus) {
                    await adapter.clearItemReviewStatus(item.itemId);
                }

                if (logExists(issueNumber)) {
                    logWebhookAction(issueNumber, 'phase_complete', `Phase ${parsedPhase.current}/${parsedPhase.total} complete`, {
                        currentPhase: parsedPhase.current,
                        totalPhases: parsedPhase.total,
                        nextPhase,
                        prNumber,
                    });
                }

                statusMessage = `üìã Phase ${parsedPhase.current}/${parsedPhase.total} complete\nüîÑ Starting Phase ${nextPhase}/${parsedPhase.total}`;
            } else {
                // Final phase complete
                if (taskBranch) {
                    const issueDetails = await adapter.getIssueDetails(issueNumber);
                    const issueTitle = issueDetails?.title || `Issue #${issueNumber}`;

                    const finalPR = await createFinalPRToMain(
                        adapter,
                        issueNumber,
                        parsedPhase.total,
                        issueTitle
                    );

                    if (finalPR) {
                        const finalPRComment = `‚úÖ **Phase ${parsedPhase.current}/${parsedPhase.total}** complete - Merged PR #${prNumber}\n\nüöÄ **All phases merged to feature branch!**\nüìã Final PR created: #${finalPR.prNumber}\n\nAwaiting admin verification via Vercel preview before merge to main.`;
                        await adapter.addIssueComment(issueNumber, finalPRComment);

                        await adapter.updateItemStatus(item.itemId, STATUSES.finalReview);

                        if (adapter.hasReviewStatusField() && item.reviewStatus) {
                            await adapter.clearItemReviewStatus(item.itemId);
                        }

                        if (logExists(issueNumber)) {
                            logWebhookAction(issueNumber, 'final_review', `All phases complete, final PR #${finalPR.prNumber} created`, {
                                totalPhases: parsedPhase.total,
                                finalPrNumber: finalPR.prNumber,
                                taskBranch,
                            });
                        }

                        isMultiPhaseMiddle = true;

                        if (appConfig.ownerTelegramChatId && process.env.TELEGRAM_BOT_TOKEN) {
                            const finalReviewMessage = [
                                'üöÄ <b>All Phases Complete - Final Review</b>',
                                '',
                                `üìã Issue: <b>${escapeHtml(issueTitle)}</b>`,
                                `üîó Issue #${issueNumber}`,
                                '',
                                `‚úÖ All ${parsedPhase.total} phases have been merged to the feature branch.`,
                                `üìã Final PR: #${finalPR.prNumber}`,
                                '',
                                'üîç <b>Please verify the complete feature via Vercel preview before merging.</b>',
                            ].join('\n');

                            const mergeFinalCallback = `merge_final:${issueNumber}:${finalPR.prNumber}`;

                            await sendNotificationToOwner(finalReviewMessage, {
                                parseMode: 'HTML',
                                inlineKeyboard: [
                                    [
                                        { text: '‚úÖ Merge Final PR', callback_data: mergeFinalCallback },
                                        { text: 'üîó View PR', url: finalPR.prUrl },
                                    ],
                                ],
                            });
                        }

                        statusMessage = `üöÄ All ${parsedPhase.total} phases complete!\nüìã Final PR #${finalPR.prNumber} created\nüìä Status: Final Review`;
                    } else {
                        const fallbackComment = `‚úÖ **Phase ${parsedPhase.current}/${parsedPhase.total}** complete - Merged PR #${prNumber}\n\n‚ö†Ô∏è Failed to create final PR. Please manually merge the feature branch (\`${taskBranch}\`) to main.`;
                        await adapter.addIssueComment(issueNumber, fallbackComment);
                        await adapter.clearImplementationPhase(item.itemId);
                        statusMessage = `üéâ All ${parsedPhase.total} phases complete!\n‚ö†Ô∏è Final PR creation failed\nüìä Status: Done`;
                    }
                } else {
                    const allPhasesCompleteComment = `‚úÖ **Phase ${parsedPhase.current}/${parsedPhase.total}** complete - Merged PR #${prNumber}\n\nüéâ **All ${parsedPhase.total} phases complete!** Issue is now Done.`;
                    await adapter.addIssueComment(issueNumber, allPhasesCompleteComment);
                    await adapter.clearImplementationPhase(item.itemId);

                    if (logExists(issueNumber)) {
                        logWebhookAction(issueNumber, 'all_phases_complete', `All ${parsedPhase.total} phases complete`, {
                            totalPhases: parsedPhase.total,
                            prNumber,
                        });
                    }

                    statusMessage = `üéâ All ${parsedPhase.total} phases complete!\nüìä Status: Done`;
                }
            }
        } else if (item) {
            try {
                await savePhaseStatusToDB(issueNumber, 1, 'merged', prNumber);
                await updateImplementationPhaseArtifact(
                    adapter,
                    issueNumber,
                    1,
                    1,
                    '',
                    'merged',
                    prNumber
                );
            } catch {
                console.error('Telegram webhook: failed to update artifact comment (single-phase)');
            }

            const completionComment = `‚úÖ Merged PR #${prNumber} - Issue complete!`;
            await adapter.addIssueComment(issueNumber, completionComment);
            statusMessage = 'üìä Status: Done';
        }

        if (!isMultiPhaseMiddle && item) {
            // Step 1: Update workflow-item status (independent try-catch - PR is already merged)
            try {
                await adapter.updateItemStatus(item.itemId, STATUSES.done);

                if (adapter.hasReviewStatusField() && item.reviewStatus) {
                    await adapter.clearItemReviewStatus(item.itemId);
                }

                if (logExists(issueNumber)) {
                    logWebhookAction(issueNumber, 'status_done', 'Issue marked as Done', {
                        status: STATUSES.done,
                        prNumber,
                    });
                }
            } catch (error) {
                console.error(`[MERGE:CRITICAL] Failed to update workflow-item status to Done for issue #${issueNumber}:`, error);
                // Continue - the PR is already merged, we still need to try updating the source document
            }

            // Sync S3 log to repo and cleanup (non-blocking)
            syncLogToRepoAndCleanup(issueNumber).catch((err) => {
                console.error(`  [LOG:S3_SYNC] Failed to sync log for issue #${issueNumber}:`, err);
            });

            // Step 2: Update source document status (independent try-catch - PR is already merged)
            try {
                const featureRequest = await featureRequests.findByGitHubIssueNumber(issueNumber);
                if (featureRequest) {
                    await featureRequests.updateFeatureRequestStatus(featureRequest._id, 'done');
                    if (logExists(issueNumber)) {
                        logWebhookAction(issueNumber, 'mongodb_updated', 'Feature request marked as done in database', {
                            featureRequestId: featureRequest._id.toString(),
                        });
                    }
                } else {
                    const bugReport = await reports.findByGitHubIssueNumber(issueNumber);
                    if (bugReport) {
                        await reports.updateReport(bugReport._id.toString(), { status: 'resolved' });
                        if (logExists(issueNumber)) {
                            logWebhookAction(issueNumber, 'mongodb_updated', 'Bug report marked as resolved in database', {
                                bugReportId: bugReport._id.toString(),
                            });
                        }
                    }
                }
            } catch (error) {
                console.error(`[MERGE:CRITICAL] Failed to update source document status for issue #${issueNumber}:`, error);
                // Log but continue - merge is done, Telegram message should still show success
            }
        }

        try {
            const prDetails = await adapter.getPRDetails(prNumber);
            if (prDetails?.headBranch) {
                await adapter.deleteBranch(prDetails.headBranch);
                if (logExists(issueNumber)) {
                    logWebhookAction(issueNumber, 'branch_deleted', `Branch ${prDetails.headBranch} deleted`, {
                        branch: prDetails.headBranch,
                    });
                }
            }
        } catch {
            // Branch may already be deleted
        }

        if (logExists(issueNumber)) {
            logWebhookPhaseEnd(issueNumber, 'PR Merge', 'success', 'telegram');
        }

        if (callbackQuery.message) {
            const originalText = callbackQuery.message.text || '';
            const statusUpdate = [
                '',
                '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ',
                '‚úÖ <b>Merged Successfully!</b>',
                `PR #${prNumber} has been squash-merged.`,
                statusMessage,
            ].join('\n');

            await editMessageText(
                botToken,
                callbackQuery.message.chat.id,
                callbackQuery.message.message_id,
                escapeHtml(originalText) + statusUpdate,
                'HTML'
            );
        }

        if (isMultiPhaseMiddle && parsedPhase && appConfig.ownerTelegramChatId && process.env.TELEGRAM_BOT_TOKEN) {
            const nextPhase = parsedPhase.current + 1;
            const message = `<b>Agent (Multi-PR):</b> ‚úÖ Phase ${parsedPhase.current}/${parsedPhase.total} merged

üîó Issue #${issueNumber}
üîÄ PR #${prNumber}

Starting Phase ${nextPhase}/${parsedPhase.total}...
Run <code>yarn agent:implement</code> to continue.`;

            await sendNotificationToOwner(message, {
                parseMode: 'HTML',
            });
        }

        if (mergeCommitSha && appConfig.ownerTelegramChatId && process.env.TELEGRAM_BOT_TOKEN) {
            const issueDetails = await adapter.getIssueDetails(issueNumber);
            const issueTitle = issueDetails?.title || `Issue #${issueNumber}`;
            const prInfo = await adapter.getPRInfo(prNumber);
            const prTitle = prInfo?.title || `PR #${prNumber}`;

            let progressMessage = '';
            if (isMultiPhaseMiddle && parsedPhase) {
                const nextPhase = parsedPhase.current + 1;
                progressMessage = `üìä Progress: Phase ${parsedPhase.current} of ${parsedPhase.total} complete\n‚è≠Ô∏è Next: Phase ${nextPhase}`;
            } else if (parsedPhase && parsedPhase.current === parsedPhase.total) {
                progressMessage = `üéâ All ${parsedPhase.total} phases complete! Feature ready.`;
            } else {
                progressMessage = `üéâ Implementation complete! Issue is now Done.`;
            }

            const prevStatus = isMultiPhaseMiddle ? 'prrev' : 'impl';
            const phaseStr = parsedPhase ? `${parsedPhase.current}/${parsedPhase.total}` : '';
            const shortSha = mergeCommitSha.slice(0, 7);
            const revertCallback = `rv:${issueNumber}:${prNumber}:${shortSha}:${prevStatus}:${phaseStr}`;

            const successMessage = [
                '‚úÖ <b>PR Merged Successfully</b>',
                '',
                `üìù PR: #${prNumber} - ${escapeHtml(prTitle)}`,
                `üîó Issue: #${issueNumber} - ${escapeHtml(issueTitle)}`,
                '',
                progressMessage,
            ].join('\n');

            await sendNotificationToOwner(successMessage, {
                parseMode: 'HTML',
                inlineKeyboard: [
                    [
                        { text: 'üìÑ View PR', url: getPrUrl(prNumber) },
                        { text: 'üìã View Issue', url: getIssueUrl(issueNumber) },
                    ],
                    [
                        { text: '‚Ü©Ô∏è Revert', callback_data: revertCallback },
                    ],
                ],
            });
        }

        return { success: true };
    } catch (error) {
        console.error(`[LOG:MERGE] Error handling merge for PR #${prNumber}, issue #${issueNumber}:`, error);
        if (logExists(issueNumber)) {
            logExternalError(issueNumber, 'telegram', error instanceof Error ? error : new Error(String(error)));
        }
        return {
            success: false,
            error: error instanceof Error ? error.message : String(error)
        };
    }
}

/**
 * Handle revert merge callback
 * Callback format: "rv:issueNumber:prNumber:shortSha:prevStatus:phase"
 */
export async function handleRevertMerge(
    botToken: string,
    callbackQuery: TelegramCallbackQuery,
    issueNumber: number,
    prNumber: number,
    shortSha: string,
    _prevStatus: string,
    phase: string
): Promise<HandlerResult> {
    try {
        const adapter = getProjectManagementAdapter();
        await adapter.init();

        const fullSha = await adapter.getMergeCommitSha(prNumber);
        if (!fullSha) {
            console.warn(`[LOG:REVERT] Could not find merge commit SHA for PR #${prNumber}, issue #${issueNumber}`);
            if (logExists(issueNumber)) {
                logWebhookAction(issueNumber, 'revert_failed', `Could not find merge commit SHA for PR #${prNumber}`, {
                    prNumber,
                    shortSha,
                });
            }
            return { success: false, error: 'Could not find merge commit SHA' };
        }

        if (!fullSha.startsWith(shortSha)) {
            console.warn(`[LOG:REVERT] Merge commit SHA mismatch for PR #${prNumber}, issue #${issueNumber}: expected ${shortSha}*, got ${fullSha}`);
            if (logExists(issueNumber)) {
                logWebhookAction(issueNumber, 'revert_failed', `Merge commit SHA mismatch for PR #${prNumber}`, {
                    prNumber,
                    expectedPrefix: shortSha,
                    actualSha: fullSha,
                });
            }
            return { success: false, error: 'Merge commit SHA mismatch' };
        }

        console.log(`Telegram webhook: creating revert PR for merge commit ${fullSha}`);

        const revertResult = await adapter.createRevertPR(fullSha, prNumber, issueNumber);
        if (!revertResult) {
            console.warn(`[LOG:REVERT] Failed to create revert PR for PR #${prNumber}, issue #${issueNumber}`);
            if (logExists(issueNumber)) {
                logWebhookAction(issueNumber, 'revert_failed', `Failed to create revert PR for PR #${prNumber} - may have conflicts`, {
                    prNumber,
                    mergeCommitSha: fullSha,
                });
            }
            return { success: false, error: 'Failed to create revert PR. There may be conflicts - please revert manually.' };
        }

        console.log(`Telegram webhook: created revert PR #${revertResult.prNumber}`);

        const items = await adapter.listItems();
        const item = items.find(i =>
            i.content?.type === 'Issue' &&
            i.content.number === issueNumber
        );

        if (item) {
            await adapter.updateItemStatus(item.id, STATUSES.implementation);
            console.log(`Telegram webhook: restored status to ${STATUSES.implementation}`);

            if (adapter.hasReviewStatusField()) {
                await adapter.updateItemReviewStatus(item.id, REVIEW_STATUSES.requestChanges);
                console.log(`Telegram webhook: set review status to ${REVIEW_STATUSES.requestChanges}`);
            }

            if (phase && adapter.hasImplementationPhaseField()) {
                await adapter.setImplementationPhase(item.id, phase);
                console.log(`Telegram webhook: restored phase to ${phase}`);
            }
        }

        const featureRequest = await featureRequests.findByGitHubIssueNumber(issueNumber);
        if (featureRequest) {
            await featureRequests.updateFeatureRequestStatus(featureRequest._id, 'in_progress');
            console.log('Telegram webhook: feature request status reverted to in_progress');
        } else {
            const bugReport = await reports.findByGitHubIssueNumber(issueNumber);
            if (bugReport) {
                await reports.updateReport(bugReport._id.toString(), { status: 'investigating' });
                console.log('Telegram webhook: bug report status reverted to investigating');
            }
        }

        if (callbackQuery.message) {
            const originalText = callbackQuery.message.text || '';
            const revertNote = [
                '',
                '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ',
                '‚Ü©Ô∏è <b>Revert Initiated</b>',
                `Revert PR #${revertResult.prNumber} created`,
                '',
                `<a href="${revertResult.url}">View Revert PR</a>`,
            ].join('\n');

            await editMessageText(
                botToken,
                callbackQuery.message.chat.id,
                callbackQuery.message.message_id,
                escapeHtml(originalText) + revertNote,
                'HTML'
            );
        }

        const issueDetails = await adapter.getIssueDetails(issueNumber);
        const issueTitle = issueDetails?.title || `Issue #${issueNumber}`;

        const confirmMessage = [
            '‚Ü©Ô∏è <b>Merge Reverted</b>',
            '',
            `üìã Issue: #${issueNumber} - ${escapeHtml(issueTitle)}`,
            `üîÄ Original PR: #${prNumber}`,
            `üîÑ Revert PR: #${revertResult.prNumber}`,
            '',
            phase ? `üìä Status: Implementation (Phase ${phase})` : 'üìä Status: Implementation',
            'üìù Review Status: Request Changes',
            '',
            '<b>Next steps:</b>',
            '1Ô∏è‚É£ Click "Merge Revert PR" below to undo the changes',
            `2Ô∏è‚É£ Go to Issue #${issueNumber} and add a comment explaining what went wrong`,
            '3Ô∏è‚É£ Run <code>yarn agent:implement</code> - the agent will read your feedback and create a new PR',
        ].join('\n');

        const mergeRevertCallback = `merge_rv:${issueNumber}:${revertResult.prNumber}`;

        await sendNotificationToOwner(confirmMessage, {
            parseMode: 'HTML',
            inlineKeyboard: [
                [
                    { text: '‚úÖ Merge Revert PR', callback_data: mergeRevertCallback },
                ],
                [
                    { text: 'üìÑ View Revert PR', url: revertResult.url },
                    { text: 'üìã View Issue', url: getIssueUrl(issueNumber) },
                ],
            ],
        });

        console.log(`Telegram webhook: completed revert handling for PR #${prNumber}`);
        if (logExists(issueNumber)) {
            logWebhookAction(issueNumber, 'revert_initiated', `Revert initiated for PR #${prNumber}`, {
                prNumber,
                shortSha,
            });
        }
        return { success: true };
    } catch (error) {
        console.error(`[LOG:REVERT] Error handling revert for PR #${prNumber}, issue #${issueNumber}:`, error);
        if (logExists(issueNumber)) {
            logExternalError(issueNumber, 'telegram', error instanceof Error ? error : new Error(String(error)));
        }
        return {
            success: false,
            error: error instanceof Error ? error.message : String(error)
        };
    }
}

/**
 * Handle merge revert PR callback
 * Callback format: "merge_rv:issueNumber:revertPrNumber"
 */
export async function handleMergeRevertPR(
    botToken: string,
    callbackQuery: TelegramCallbackQuery,
    issueNumber: number,
    revertPrNumber: number
): Promise<HandlerResult> {
    try {
        const adapter = getProjectManagementAdapter();
        await adapter.init();

        const prInfo = await adapter.getPRInfo(revertPrNumber);
        if (!prInfo) {
            console.warn(`[LOG:REVERT] Revert PR #${revertPrNumber} not found for issue #${issueNumber}`);
            return { success: false, error: 'Revert PR not found' };
        }

        const prDetails = await adapter.getPRDetails(revertPrNumber);
        if (!prDetails) {
            console.warn(`[LOG:REVERT] Could not get revert PR #${revertPrNumber} details for issue #${issueNumber}`);
            return { success: false, error: 'Could not get revert PR details' };
        }
        if (prDetails.merged) {
            console.warn(`[LOG:REVERT] Revert PR #${revertPrNumber} already merged for issue #${issueNumber}`);
            return { success: false, error: 'Revert PR already merged' };
        }
        if (prDetails.state === 'closed') {
            console.warn(`[LOG:REVERT] Revert PR #${revertPrNumber} is closed for issue #${issueNumber}`);
            return { success: false, error: 'Revert PR is closed' };
        }

        const commitTitle = prInfo.title;
        const commitBody = `Part of #${issueNumber}`;

        await adapter.mergePullRequest(revertPrNumber, commitTitle, commitBody);
        console.log(`Telegram webhook: merged revert PR #${revertPrNumber}`);

        try {
            await adapter.deleteBranch(prDetails.headBranch);
            console.log(`Telegram webhook: deleted revert branch ${prDetails.headBranch}`);
        } catch {
            console.log('Telegram webhook: revert branch already deleted or not found');
        }

        if (callbackQuery.message) {
            const originalText = callbackQuery.message.text || '';
            const mergedNote = [
                '',
                '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ',
                '‚úÖ <b>Revert PR Merged</b>',
                'Changes have been reverted on main.',
                '',
                '<b>Next steps:</b>',
                `1Ô∏è‚É£ Go to Issue #${issueNumber} and add a comment explaining what went wrong`,
                '2Ô∏è‚É£ Run <code>yarn agent:implement</code> - the agent will read your feedback and create a new PR',
            ].join('\n');

            await editMessageText(
                botToken,
                callbackQuery.message.chat.id,
                callbackQuery.message.message_id,
                escapeHtml(originalText) + mergedNote,
                'HTML'
            );
        }

        console.log(`Telegram webhook: completed merge revert PR #${revertPrNumber}`);
        if (logExists(issueNumber)) {
            logWebhookAction(issueNumber, 'revert_merged', `Revert PR #${revertPrNumber} merged`, {
                revertPrNumber,
            });
        }
        return { success: true };
    } catch (error) {
        console.error(`[LOG:REVERT] Error merging revert PR #${revertPrNumber} for issue #${issueNumber}:`, error);
        if (logExists(issueNumber)) {
            logExternalError(issueNumber, 'telegram', error instanceof Error ? error : new Error(String(error)));
        }
        return {
            success: false,
            error: error instanceof Error ? error.message : String(error)
        };
    }
}
